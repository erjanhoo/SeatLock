# Техническое задание: CinemaCore API (High-Load Booking System)

## 1. Цель проекта

Разработать отказоустойчивый API для системы бронирования билетов в кинотеатр.
**Ключевая задача:** Реализовать механизм конкурентного бронирования мест (когда 100 пользователей пытаются купить одно место одновременно), исключив возможность овербукинга (Double Booking).

## 2. Стек технологий

- **Язык:** Python 3.10+
- **Фреймворк:** Django 4.x + Django REST Framework (DRF)
- **База данных:** PostgreSQL (использование транзакций, индексов, блокировок)
- **Кэш / Брокер:** Redis
- **Асинхронность:** Celery (фоновые задачи)
- **Контейнеризация:** Docker, Docker Compose
- **Платежи:** Stripe (Test Mode)

## 3. Бизнес-логика и "Киллер-фичи" (Must Have для портфолио)

### 3.1. Жизненный цикл брони

Бронь (Reservation) проходит через следующие статусы:

- **PENDING (Ожидание):** Пользователь выбрал место. Система временно "замораживает" его на 15 минут. Никто другой не может его выбрать.
- **CONFIRMED (Оплачено):** Пришло подтверждение от Stripe (Webhook). Билет отправлен на почту.
- **CANCELLED (Отменено):** Пользователь не успел оплатить за 15 минут, или оплата не прошла. Место снова становится AVAILABLE.

### 3.2. Защита от Race Conditions (Состояние гонки)

При создании бронирования (`POST /api/bookings/`) необходимо использовать пессимистическую блокировку (`select_for_update` в БД), чтобы гарантировать атомарность операции.

**Требование:** Если два запроса приходят в одну миллисекунду, только один должен получить `201 Created`, второй — `409 Conflict` или `400 Bad Request`.

### 3.3. Платежный шлюз

- Не храним данные карт.
- Используем Stripe Payment Intents.
- Статус брони меняется на **CONFIRMED** только по входящему вебхуку (Webhook) от Stripe, а не по ответу фронтенда.

### 3.4. Фоновая очистка (The Cleaner)

- При создании брони запускается отложенная задача Celery (Delayed Task) ровно на 15 минут.
- Через 15 минут воркер проверяет статус: если всё ещё **PENDING**, бронь отменяется, место освобождается.

## 4. Структура БД (Сущности)

- **Movie (Фильм):** Название, описание, длительность.
- **Hall (Зал):** Название, конфигурация.
- **Seat (Место):** Ряд, номер места, связь с Hall. **Уникальный констрэйн:** `(hall_id, row, number)`.
- **Screening (Сеанс):** Связь Movie + Hall + start_time + price.
- **Reservation (Бронь):** Связь User + Screening + Seat. Хранит status и payment_intent_id. **Уникальный констрэйн:** `(screening_id, seat_id)` где `status != CANCELLED`.

## 5. Основные API Эндпоинты

### Public (Без авторизации)

- `GET /api/movies/` — Список фильмов.
- `GET /api/screenings/{id}/seats/` — Матрица мест для сеанса.
  - **Важно:** Должен возвращать статус каждого места: `{row: 5, seat: 10, status: "AVAILABLE" | "LOCKED" | "SOLD"}`.

### Private (Требуется JWT)

- `POST /api/bookings/` — Создать бронь.
  - **Input:** `{screening_id: 1, seat_ids: [55, 56]}`
  - **Logic:** Старт транзакции -> Блокировка строк -> Проверка доступности -> Создание PENDING брони -> Запуск таймера Celery -> Ответ с payment_url (или client_secret).
- `GET /api/my-bookings/` — История заказов юзера.

### System (Webhooks)

- `POST /api/webhooks/stripe/` — Принимает события от Stripe (`payment_intent.succeeded`). Проверяет подпись (Signature).

## 6. Требования к Инфраструктуре (DevOps)

Проект должен запускаться одной командой: `docker-compose up --build`.

**Контейнеры:**

- `db`: PostgreSQL 15+
- `web`: Gunicorn + Django
- `worker`: Celery Worker (для задач)
- `redis`: Брокер сообщений и кэш
- `nginx`: Раздача статики (admin panel styles) и проксирование запросов к web.

## 7. Критерии приемки (Definition of Done)

1.  Код написан по PEP8, используются Type Hints.
2.  Написан скрипт нагрузочного тестирования (простой python-файл), который пытается купить одно место в 10 потоков. Результат: 1 успех, 9 ошибок.
3.  **README.md** содержит инструкцию по запуску и описание архитектурного решения (почему выбрана пессимистическая блокировка).
